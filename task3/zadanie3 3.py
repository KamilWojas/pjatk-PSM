# -*- coding: utf-8 -*-
"""Zadanie3

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GKjTNapEqj38tbQKHySR3J03RwDZ9Jho
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation


g = 9.81
L = 1.0
m = 1.0
theta0 = np.pi / 4
omega0 = 0.0

T = 10
dt = 0.01
times = np.arange(0, T, dt)


def euler_step(theta, omega, dt):
    domega_dt = -(g / L) * np.sin(theta)
    return theta + omega * dt, omega + domega_dt * dt

def midpoint_step(theta, omega, dt):
    domega_dt = -(g / L) * np.sin(theta)
    theta_mid = theta + omega * dt / 2
    omega_mid = omega + domega_dt * dt / 2
    domega_mid_dt = -(g / L) * np.sin(theta_mid)
    return theta + omega_mid * dt, omega + domega_mid_dt * dt

def rk4_step(theta, omega, dt):
    k1_theta, k1_omega = omega, -(g / L) * np.sin(theta)
    k2_theta, k2_omega = omega + 0.5 * k1_omega * dt, -(g / L) * np.sin(theta + 0.5 * k1_theta * dt)
    k3_theta, k3_omega = omega + 0.5 * k2_omega * dt, -(g / L) * np.sin(theta + 0.5 * k2_theta * dt)
    k4_theta, k4_omega = omega + k3_omega * dt, -(g / L) * np.sin(theta + k3_theta * dt)
    return (theta + (k1_theta + 2*k2_theta + 2*k3_theta + k4_theta) * dt / 6,
            omega + (k1_omega + 2*k2_omega + 2*k3_omega + k4_omega) * dt / 6)


results = {method.__name__: {'theta': [], 'omega': [], 'energy_potential': [], 'energy_kinetic': [], 'energy_total': []}
           for method in [euler_step, midpoint_step, rk4_step]}

for method in [euler_step, midpoint_step, rk4_step]:
    theta, omega = theta0, omega0
    for t in times:
        energy_kinetic = 0.5 * m * (L * omega)**2
        energy_potential = m * g * L * (1 - np.cos(theta))
        energy_total = energy_kinetic + energy_potential
        results[method.__name__]['theta'].append(theta)
        results[method.__name__]['omega'].append(omega)
        results[method.__name__]['energy_potential'].append(energy_potential)
        results[method.__name__]['energy_kinetic'].append(energy_kinetic)
        results[method.__name__]['energy_total'].append(energy_total)
        theta, omega = method(theta, omega, dt)

for method, data in results.items():
    initial_energy = data['energy_total'][0]
    final_energy = data['energy_total'][-1]
    energy_difference = abs(final_energy - initial_energy)
    print(f"{method} energy difference: {energy_difference}")


fig, axs = plt.subplots(3, 1, figsize=(10, 15))
for i, (method, data) in enumerate(results.items()):
    axs[i].plot(times, data['energy_potential'], label='Energia potencjalna', linestyle='--')
    axs[i].plot(times, data['energy_kinetic'], label='Energia kinetyczna', linestyle='-.')
    axs[i].plot(times, data['energy_total'], label='Energia całkowita')
    axs[i].set_title(method)
    axs[i].legend()
plt.tight_layout()


fig, ax = plt.subplots()
line, = ax.plot([], [], 'o-', lw=2)
ax.set_xlim(-1.2 * L, 1.2 * L)
ax.set_ylim(-1.2 * L, 1.2 * L)
ax.set_aspect('equal')

def init():
    line.set_data([], [])
    return line,

def animate(i):
    x = L * np.sin(results['rk4_step']['theta'][i])
    y = -L * np.cos(results['rk4_step']['theta'][i])
    line.set_data([0, x], [0, y])
    return line,

ani = FuncAnimation(fig, animate, frames=len(times), init_func=init, blit=True)

ax_traj = plt.subplot(313)
ax_traj.set_aspect('equal')
ax_traj.set_xlim(-1.2 * L, 1.2 * L)
ax_traj.set_ylim(-1.2 * L, 1.2 * L)
ax_traj.set_xlabel('x')
ax_traj.set_ylabel('y')
ax_traj.set_title('Trajektoria ruchu wahadła')

lines_traj = [ax_traj.plot([], [], lw=2, label=method)[0] for method in results.keys()]

def init_traj():
    for line_traj in lines_traj:
        line_traj.set_data([], [])
    return lines_traj

def animate_traj(i):
    for j, (method, data) in enumerate(results.items()):
        theta = data['theta'][:i+1]
        x = L * np.sin(theta)
        y = -L * np.cos(theta)
        lines_traj[j].set_data(x, y)
    return lines_traj

ani_traj = FuncAnimation(fig, animate_traj, frames=len(times), init_func=init_traj, blit=True)

plt.show()